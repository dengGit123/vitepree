## 命名空间（Namespace）
* 用于避免全局作用域的命名冲突
## 一. 基础定义与导出
* 使用`namespace`关键字定义命名空间，内部成员需通过`export`暴露才能被外部访问
```typescript
namespace MyNamespace {
    export const PI = 3.14; // 导出变量
    export function calcArea(r: number) { // 导出函数
        return PI * r ** 2;
    }
}
console.log(MyNamespace.calcArea(2)); // 调用导出函数
```
## 二. 嵌套与多文件拆分
### 1. **嵌套命名空间**‌：支持层级结构以组织复杂代码
```typescript
namespace Outer {
    export namespace Inner {
        export const value = 42;
    }
}
console.log(Outer.Inner.value); // 访问嵌套成员
```
### 2. **‌多文件共享命名空间**‌：同名命名空间在不同文件中会自动合并
```typescript
// file1.ts
namespace Shared {
    export function funcA() {}
}
// file2.ts
namespace Shared {
    export function funcB() {}
}
// 合并后可通过Shared.funcA和Shared.funcB访问
```
## 三. 命名空间与模块有何区别
### 1. 作用域隔离机制
* 1. **‌模块**‌：通过**文件级作用域**实现隔离，任何包含顶级`import`或`export`的文件自动成为模块，其内部成员默认私有，需显式导出才能被外部访问。这种设计有效避免全局污染，适合大型项目
* 2. **命名空间**‌：通过`namespace`关键字创建逻辑分组，成员需通过`export`暴露。虽然组织在命名空间内，但本质上仍属于**全局作用域**，仅通过命名限定避免冲突
### 2. 代码组织方式
* 1. **模块化方案‌**：
 * 支持动态导入（`import()`）和按需加载
 * 提供默认导出（`export default`）和命名导出（`export const`）
 * 编译后依赖模块加载器（如Webpack）处理依赖关系
* 2. **命名空间方案‌**
 * 通过嵌套命名空间实现层级结构
 * 跨文件扩展需使用`///<reference path="..." />`指令
 * 编译为IIFE（立即执行函数）实现作用域隔离
