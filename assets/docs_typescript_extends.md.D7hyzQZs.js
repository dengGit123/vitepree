import{_ as a,c as n,o as e,ae as t}from"./chunks/framework.Dwd5JCA7.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/typescript/extends.md","filePath":"docs/typescript/extends.md","lastUpdated":1758337320000}'),p={name:"docs/typescript/extends.md"};function l(i,s,r,o,c,d){return e(),n("div",null,[...s[0]||(s[0]=[t(`<h2 id="extends关键字" tabindex="-1">extends关键字 <a class="header-anchor" href="#extends关键字" aria-label="Permalink to &quot;extends关键字&quot;">​</a></h2><ul><li>约束类型结构</li></ul><h2 id="一-泛型约束" tabindex="-1">一. 泛型约束 <a class="header-anchor" href="#一-泛型约束" aria-label="Permalink to &quot;一. 泛型约束&quot;">​</a></h2><ol><li>限制类型参数范围 确保泛型参数符合特定<strong>类型结构</strong></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function logLength&lt;T extends { length: number }&gt;(arg: T): void {</span></span>
<span class="line"><span>  console.log(arg.length);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//该例中T必须包含length属性</span></span></code></pre></div><ol start="2"><li>多重约束 可以同时约束多个类型</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function mergeProps&lt;T extends { a: number } &amp; { b: string }&gt;(obj: T) {</span></span>
<span class="line"><span>  return obj.a + obj.b.length;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//要求T同时满足两个接口的结构</span></span></code></pre></div><h2 id="二-类型继承" tabindex="-1">二. 类型继承 <a class="header-anchor" href="#二-类型继承" aria-label="Permalink to &quot;二. 类型继承&quot;">​</a></h2><ol><li>接口继承 支持单继承或多继承（合并多个接口）,一个接口可以继承另一个接口，从而扩展其属性或方法。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface Animal {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Dog extends Animal {</span></span>
<span class="line"><span>  breed: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//子接口自动包含父接口的成员</span></span></code></pre></div><ol start="2"><li>类继承 支持单继承，一个类可以继承另一个类的属性和方法。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class Animal { move() {} }</span></span>
<span class="line"><span>class Dog extends Animal { bark() {} }</span></span></code></pre></div><h2 id="三-条件类型" tabindex="-1">三. 条件类型 <a class="header-anchor" href="#三-条件类型" aria-label="Permalink to &quot;三. 条件类型&quot;">​</a></h2><ol><li>类型判断 <ul><li>类似三元运算符的类型逻辑：</li><li>如果是泛型，会泛型中每一个类型都会单独去比较条件。</li><li>如果不是泛型，则会直接比较条件。</li></ul></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 会得到never, 因为是 \`string | number\`整体和\`string | number | boolean\`比较，显然前者不是后者的子类型。</span></span>
<span class="line"><span>type a = string | number extends string | number | boolean ? string : never; </span></span>
<span class="line"><span></span></span>
<span class="line"><span>type a&lt;T&gt; = T extends string | number ? T : never;</span></span>
<span class="line"><span>//会得到string | number, 因为是泛型，所以每个类型都会单独去比较条件。</span></span>
<span class="line"><span>type a1 = a&lt;string | number&gt; // string | number</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type IsString&lt;T&gt; = T extends string ? true : false;</span></span>
<span class="line"><span>//判断T是否为string的子类型</span></span></code></pre></div><ol start="2"><li>分布式条件类型 联合类型会触发分布式计算 <ul><li>当T为联合类型时，每个成员都会独立计算条件类型，即<strong>T</strong>的每一个类型，都会单独去比较条件。</li></ul></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>type ToArray&lt;T&gt; = T extends any ? T[] : never;</span></span>
<span class="line"><span>type StrOrNumArr = ToArray&lt;string | number&gt;; // string[] | number[]</span></span>
<span class="line"><span>//每个联合类型成员独立计算;即等价与 type StrOrNumArr = ToArray&lt;string&gt; | ToArray&lt;number&gt;;</span></span></code></pre></div>`,18)])])}const u=a(p,[["render",l]]);export{h as __pageData,u as default};
