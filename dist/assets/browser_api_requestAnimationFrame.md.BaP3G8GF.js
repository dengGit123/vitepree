import{_ as e,c as t,o as n,ae as i}from"./chunks/framework.DzsIGSTZ.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser_api/requestAnimationFrame.md","filePath":"browser_api/requestAnimationFrame.md","lastUpdated":1757172066000}'),s={name:"browser_api/requestAnimationFrame.md"};function l(r,a,o,d,p,c){return n(),t("div",null,a[0]||(a[0]=[i(`<h2 id="requestanimationframe" tabindex="-1">requestAnimationFrame <a class="header-anchor" href="#requestanimationframe" aria-label="Permalink to &quot;requestAnimationFrame&quot;">​</a></h2><ul><li>用于高效执行动画</li><li>其核心原理是与浏览器刷新率同步执行回调函数，实现更流畅的动画效果</li></ul><h2 id="核心原理与优势" tabindex="-1">核心原理与优势 <a class="header-anchor" href="#核心原理与优势" aria-label="Permalink to &quot;核心原理与优势&quot;">​</a></h2><ol><li>帧同步机制</li></ol><ul><li>以显示器刷新频率（通常为60Hz，即16.7ms/帧）调用回调函数，避免过度绘制或丢帧</li></ul><ol start="2"><li>自动暂停优化</li></ol><ul><li>当页面不可见或浏览器标签页不活动时，自动暂停执行回调函数，减少资源消耗</li></ul><ol start="3"><li>‌高性能调度</li></ol><ul><li>回调函数在浏览器重绘前执行，优先级高于<code>setTimeout/setInterval</code>，避免任务队列阻塞</li></ul><h2 id="基础用法" tabindex="-1">基础用法 <a class="header-anchor" href="#基础用法" aria-label="Permalink to &quot;基础用法&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let animationId;</span></span>
<span class="line"><span>function animate() {</span></span>
<span class="line"><span>  // 动画逻辑</span></span>
<span class="line"><span>  animationId = requestAnimationFrame(animate); // 递归调用</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>animate();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 停止动画</span></span>
<span class="line"><span>cancelAnimationFrame(animationId);</span></span></code></pre></div><h2 id="对比传统方法" tabindex="-1">对比传统方法 <a class="header-anchor" href="#对比传统方法" aria-label="Permalink to &quot;对比传统方法&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>requestAnimationFrame</th><th>setTimeOut/setInterval</th></tr></thead><tbody><tr><td>时间精度</td><td>与刷新率同步</td><td>受任务队列影响不稳定</td></tr><tr><td>后台标签页性能</td><td>自动暂停</td><td>持续执行</td></tr><tr><td>动画流畅度</td><td>高</td><td>可能出现卡顿</td></tr></tbody></table><h2 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h2><ol><li>动画效果</li><li>动态数据可视化:实时图表更新时避免渲染抖动</li></ol><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><ol><li>‌递归调用时需保存<code>animationId</code>，以便后续取消动画</li></ol><ul><li>回调函数需手动调用<code>requestAnimationFrame</code>以持续动画</li></ul><ol start="2"><li>使用<code>cancelAnimationFrame</code>正确停止动画，防止内存泄漏</li></ol>`,19)]))}const u=e(s,[["render",l]]);export{h as __pageData,u as default};
