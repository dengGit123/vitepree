import{_ as s,c as e,o as l,ae as n}from"./chunks/framework.DzsIGSTZ.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser_api/Worker‌.md","filePath":"browser_api/Worker‌.md","lastUpdated":1757172066000}'),o={name:"browser_api/Worker‌.md"};function r(i,a,t,p,c,d){return l(),e("div",null,a[0]||(a[0]=[n(`<h2 id="worker‌" tabindex="-1">Worker‌ <a class="header-anchor" href="#worker‌" aria-label="Permalink to &quot;Worker‌&quot;">​</a></h2><ul><li>是一种允许在后台线程中运行脚本的 API</li><li>用于解决主线程因耗时任务导致的页面卡顿问题</li></ul><h2 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to &quot;核心特性&quot;">​</a></h2><ol><li>独立线程执行</li></ol><ul><li>在独<strong>立于主线程</strong>的后台运行，不会阻塞 UI 渲染和用户交互</li></ul><ol start="2"><li>通信机制</li></ol><ul><li>通过 <code>postMessage</code> 和 <code>onmessage</code> 实现主线程与 Worker 间的数据传递</li></ul><ol start="3"><li>限制</li></ol><ul><li>受同源策略限制，只能与创建它的页面在同一域下通信</li><li>无法直接操作 <code>DOM</code> 或访问 <code>window</code> 对象</li></ul><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><ol><li>‌密集型计算‌</li></ol><ul><li>如大数运算、图像处理等耗时任务</li></ul><ol start="2"><li>‌实时数据处理‌</li></ol><ul><li>日志分析、流媒体解码等需持续运行的后台任务 3.离线缓存与预加载‌</li><li>Service Worker 可用于资源缓存和离线体验优化</li></ul><h2 id="基础用法示例" tabindex="-1">基础用法示例 <a class="header-anchor" href="#基础用法示例" aria-label="Permalink to &quot;基础用法示例&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 主线程</span></span>
<span class="line"><span>const worker = new Worker(&#39;worker.js&#39;);</span></span>
<span class="line"><span>worker.postMessage({ data: 1000 }); // 发送数据</span></span>
<span class="line"><span>worker.onmessage = (e) =&gt; {</span></span>
<span class="line"><span>  console.log(&#39;结果:&#39;, e.data); // 接收结果</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// worker.js</span></span>
<span class="line"><span>self.onmessage = (e) =&gt; {</span></span>
<span class="line"><span>  const result = heavyTask(e.data.data); // 执行计算</span></span>
<span class="line"><span>  self.postMessage(result); // 返回结果</span></span>
<span class="line"><span>};</span></span></code></pre></div><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><ol><li>‌兼容性</li></ol><ul><li>并非所有浏览器都支持，需检查兼容性</li></ul><ol start="2"><li>资源限制</li></ol><ul><li>Worker 线程的资源有限，需合理分配</li></ul><ol start="3"><li>错误处理</li></ol><ul><li><code>onerror</code> 事件可用于捕获 Worker 中的错误</li></ul>`,23)]))}const k=s(o,[["render",r]]);export{h as __pageData,k as default};
